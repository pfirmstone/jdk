/* 
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * THE FILE HAS BEEN AUTOGENERATED BY MSGTOOL TOOL.
 * All changes made to this file manually will be overwritten 
 * if this tool runs again. Better make changes in the template file.
 * - Shamelessly taken from Apache Harmony.
 */

package au.zeus.jdk.authorization.impl;


import java.util.Map;
import java.util.HashMap;



/**
 * This class retrieves strings from a resource bundle and returns them,
 * formatting them with MessageFormat when required.
 * <p>
 * It is used by the system classes to provide national language support, by
 * looking up messages in the <code>
 *    org.apache.harmony.security.internal.nls.messages
 * </code>
 * resource bundle. Note that if this file is not available, or an invalid key
 * is looked up, or resource bundle support is not available, the key itself
 * will be returned as the associated message. This means that the <em>KEY</em>
 * should a reasonable human-readable (english) string.
 * @since 3.0.0
 */
public class Messages {
    
    static final Map<String,String> messages = new HashMap<>();
    
    static{
        //ConcurrentPolicyFile
        messages.put("security.1A4","Unable to resolve Principal name: {0}");
        messages.put("security.1A5","Unable to grant Permission: {0} {1}");
        messages.put("security.1A6","Unable to resolve Signer name: {0}");
        messages.put("security.1A7","Unable to resolve CodeSource name: {0}");
        messages.put("security.1A8","Problem parsing policy: {0} {1}");
        messages.put("security.1A9","Unable to process grant {0}");
        messages.put("security.143","Error expanding alias : {0}");
        messages.put("security.144","Self protocol is valid only in context of Principal-based grant entries");
        messages.put("security.145","Unknown expansion protocol : {0}");
        messages.put("security.146","No KeyStore to resolve signers : \"{0}\"");
        messages.put("security.147","No KeyStore to resolve principal by alias : \"{0}\"");
        messages.put("security.148","Invalid certificate for alias \"{0}\" : {1}. Only X509Certificate should be aliased to principals.");
        messages.put("security.14F", "security.14F=Unknown key: {0} ");
        messages.put("security.150", "No suitable constructors found in permission class : {0}. Zero, one or two-argument constructor is expected");        
        messages.put("security.8A","Expected syntax is : keystore \"url\"[, \"type\"]");
        messages.put("security.8B","Expected syntax is : signedby \"name1,...,nameN\"");
        messages.put("security.8C","Expected syntax is : codebase \"url\"");
        messages.put("security.8D","Expected syntax is : principal [class_name] \"principal_name\"");
        messages.put("security.8E","Expected syntax is : permission permission_class_name [\"target_name\"] [, \"action_list\"] [, signedby \"name1,...,nameN\"]");
        messages.put("security.8F","Unexpected token encountered: {0}. {1}");
        messages.put("security.89","Expected entries are : \"grant\" or \"keystore\"");
        messages.put("security.90","Unexpected token encountered: {0}");
        messages.put("security.91","Class cannot be null or empty");
        //Uri
        messages.put("luni.82", "Relative path");
        messages.put("luni.83", "Scheme expected");
        messages.put("luni.84", "Scheme-specific part expected");
        messages.put("luni.85", "Illegal character in scheme");
        messages.put("luni.85A", "Illegal character in scheme: {0}");
        messages.put("luni.86", "{0} in schemeSpecificPart");
        messages.put("luni.87", "{0} in authority");
        messages.put("luni.88", "{0} in path");
        messages.put("luni.89", "{0} in query");
        messages.put("luni.8A", "{0} in fragment");
        messages.put("luni.91", "URI is not absolute");
        
        messages.put("luni.9E", "method has not been implemented yet");
        messages.put("luni.9F", "Authority expected");
        messages.put("luni.A0", "Expected host");
       
        messages.put("luni.7D", "Incomplete % sequence");
        messages.put("luni.7E", "Invalid % sequence ({0})");
        messages.put("luni.7F", "Illegal character");
    }

    /**
     * Retrieves a message which has no arguments.
     * 
     * @param msg
     *            String the key to look up.
     * @return String the message for that key in the system message bundle.
     */
    static public String getString(String msg) {
        String result = messages.get(msg);
        if (result != null) return result;
        return msg;
    }

    /**
     * Retrieves a message which takes 1 argument.
     * 
     * @param msg
     *            String the key to look up.
     * @param arg
     *            Object the object to insert in the formatted output.
     * @return String the message for that key in the system message bundle.
     */
    static public String getString(String msg, Object arg) {
        return getString(msg, new Object[] { arg });
    }

    /**
     * Retrieves a message which takes 1 integer argument.
     * 
     * @param msg
     *            String the key to look up.
     * @param arg
     *            int the integer to insert in the formatted output.
     * @return String the message for that key in the system message bundle.
     */
    static public String getString(String msg, int arg) {
        return getString(msg, new Object[] { Integer.toString(arg) });
    }

    /**
     * Retrieves a message which takes 1 character argument.
     * 
     * @param msg
     *            String the key to look up.
     * @param arg
     *            char the character to insert in the formatted output.
     * @return String the message for that key in the system message bundle.
     */
    static public String getString(String msg, char arg) {
        return getString(msg, new Object[] { String.valueOf(arg) });
    }

    /**
     * Retrieves a message which takes 2 arguments.
     * 
     * @param msg
     *            String the key to look up.
     * @param arg1
     *            Object an object to insert in the formatted output.
     * @param arg2
     *            Object another object to insert in the formatted output.
     * @return String the message for that key in the system message bundle.
     */
    static public String getString(String msg, Object arg1, Object arg2) {
        return getString(msg, new Object[] { arg1, arg2 });
    }

    /**
     * Retrieves a message which takes several arguments.
     * 
     * @param msg
     *            String the key to look up.
     * @param args
     *            Object[] the objects to insert in the formatted output.
     * @return String the message for that key in the system message bundle.
     */
    static public String getString(String msg, Object[] args) {
        if (args!= null) return format(getString(msg), args);
        return getString(msg);
    }
    
    /**
     * Generates a formatted text string given a source string containing
     * "argument markers" of the form "{argNum}" where each argNum must be in
     * the range 0..9. The result is generated by inserting the toString of each
     * argument into the position indicated in the string.
     * <p>
     * To insert the "{" character into the output, use a single backslash
     * character to escape it (i.e. "\{"). The "}" character does not need to be
     * escaped.
     * 
     * @param format
     *            String the format to use when printing.
     * @param args
     *            Object[] the arguments to use.
     * @return String the formatted message.
     */
    public static String format(String format, Object[] args) {
        StringBuilder answer = new StringBuilder(format.length()
                + (args.length * 20));
        String[] argStrings = new String[args.length];
        for (int i = 0; i < args.length; ++i) {
            if (args[i] == null) {
                argStrings[i] = "<null>"; 
            }	//$NON-NLS-1$
            else {
                argStrings[i] = args[i].toString();
            }
        }
        int lastI = 0;
        for (int i = format.indexOf('{', 0); i >= 0; i = format.indexOf('{',
                lastI)) {
            if (i != 0 && format.charAt(i - 1) == '\\') {
                // It's escaped, just print and loop.
                if (i != 1) {
                    answer.append(format.substring(lastI, i - 1));
                }
                answer.append('{');
                lastI = i + 1;
            } else {
                // It's a format character.
                if (i > format.length() - 3) {
                    // Bad format, just print and loop.
                    answer.append(format.substring(lastI, format.length()));
                    lastI = format.length();
                } else {
                    int argnum = (byte) Character.digit(format.charAt(i + 1),
                            10);
                    if (argnum < 0 || format.charAt(i + 2) != '}') {
                        // Bad format, just print and loop.
						answer.append(format.substring(lastI, i + 1));
						lastI = i + 1;
                    } else {
                        // Got a good one!
                        answer.append(format.substring(lastI, i));
                        if (argnum >= argStrings.length) {
                            answer.append("<missing argument>"); 
                        }	//$NON-NLS-1$
                        else {
                            answer.append(argStrings[argnum]);
                        }
						lastI = i + 3;
                    }
                }
            }
        }
        if (lastI < format.length()) {
            answer.append(format.substring(lastI, format.length()));
        }
        return answer.toString();
    }

}
